<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画像上部空白自動切り取りツール</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            margin-bottom: 30px;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9ff;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ebff;
        }

        .upload-icon {
            font-size: 3rem;
            color: #667eea;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #333;
        }

        .upload-subtext {
            color: #666;
            font-size: 0.9rem;
        }

        .settings-section {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            font-size: 1.1rem;
        }

        /* スライダー設定 */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #667eea 0%, #667eea var(--value), #ddd var(--value), #ddd 100%);
            outline: none;
            transition: background 0.3s;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #764ba2;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }

        .slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            background: #764ba2;
        }

        .slider-value {
            width: 80px;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            text-align: center;
        }

        .setting-description {
            font-size: 0.85rem;
            color: #666;
            margin-top: 8px;
            line-height: 1.4;
        }

        /* 圧縮設定のスタイル */
        .compression-toggle {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: #fff;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: #ddd;
            border-radius: 15px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(30px);
        }

        .compression-label {
            font-weight: bold;
            color: #333;
        }

        .compression-info {
            font-size: 0.85rem;
            color: #666;
        }

        /* ボタンスタイル */
        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-reset {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }

        .btn-reset:hover {
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.6);
        }

        .processing-info {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            background: #f8f9ff;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results-section {
            display: none;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .results-title {
            font-size: 1.5rem;
            color: #333;
        }

        .download-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .download-all-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }

        .download-all-btn:hover {
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.6);
        }

        .download-selected-btn {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4);
        }

        .download-selected-btn:hover {
            box-shadow: 0 6px 20px rgba(255, 193, 7, 0.6);
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }

        .image-item {
            background: white;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
            position: relative;
        }

        .image-item:hover {
            transform: translateY(-5px);
        }

        .image-item.selected {
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5);
            border: 2px solid #667eea;
        }

        .image-checkbox {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 24px;
            height: 24px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .image-checkbox.checked {
            background: #667eea;
        }

        .image-checkbox.checked::after {
            content: '✓';
            color: white;
            font-weight: bold;
        }

        .image-container {
            width: 100%;
            aspect-ratio: 3/4;
            background: #f0f0f0;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .result-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-info {
            font-size: 0.8rem;
            color: #666;
            text-align: center;
        }

        .original-name {
            font-weight: bold;
            margin-bottom: 3px;
            word-break: break-all;
        }

        .size-reduction {
            color: #28a745;
        }

        .compressed-badge {
            background: #ffc107;
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            margin-top: 3px;
            display: inline-block;
        }

        /* プレビューモーダル */
        .preview-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            overflow: auto;
        }

        .preview-modal-content {
            position: relative;
            margin: 20px auto;
            max-width: 90%;
            max-height: 90vh;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .preview-container {
            position: relative;
            background: white;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .preview-image {
            max-width: 80vw;
            max-height: 80vh;
            display: block;
            border-radius: 8px;
        }

        .preview-info {
            background: white;
            padding: 15px;
            border-radius: 0 0 10px 10px;
            text-align: center;
        }

        .preview-close {
            position: absolute;
            top: -40px;
            right: 0;
            color: white;
            font-size: 36px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .preview-close:hover {
            color: #ff6b6b;
        }

        .preview-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 48px;
            color: white;
            cursor: pointer;
            padding: 20px;
            transition: color 0.3s;
            user-select: none;
        }

        .preview-nav:hover {
            color: #667eea;
        }

        .preview-prev {
            left: 20px;
        }

        .preview-next {
            right: 20px;
        }

        #fileInput {
            display: none;
        }

        .select-all-container {
            margin-bottom: 15px;
            text-align: right;
        }

        .select-all-btn {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            padding: 8px 20px;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .main-card {
                padding: 20px;
            }

            .image-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .preview-nav {
                font-size: 32px;
                padding: 10px;
            }

            .action-buttons {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 画像上部空白自動切り取りツール</h1>
            <p>ゲーム画像の上部空白を自動検出して一括切り取り</p>
        </div>

        <div class="main-card">
            <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                <div class="upload-icon">📷</div>
                <div class="upload-text">画像をドラッグ&ドロップまたはクリックして選択</div>
                <div class="upload-subtext">複数の画像を同時選択可能（JPG、PNG対応）</div>
            </div>

            <input type="file" id="fileInput" multiple accept="image/*">

            <div class="settings-section">
                <div class="setting-group">
                    <label class="setting-label">バッファ設定</label>
                    <div class="slider-container">
                        <input type="range" id="bufferSlider" class="slider" min="0" max="200" value="70">
                        <input type="number" id="bufferValue" class="slider-value" min="0" max="200" value="70">
                    </div>
                    <div class="setting-description">※検出位置から少し上を切り取り開始点とし、重要な部分の保護を行います</div>
                </div>

                <div class="compression-toggle">
                    <div class="toggle-switch active" id="compressionToggle" onclick="toggleCompression()">
                        <div class="toggle-slider"></div>
                    </div>
                    <div>
                        <div class="compression-label">画像圧縮（499KB以下）</div>
                        <div class="compression-info">高品質を維持しながら499KB以下に最適化します</div>
                    </div>
                </div>
            </div>

            <div class="action-buttons">
                <button id="processBtn" class="btn" onclick="processImages()">📸 画像を処理</button>
                <button id="resetBtn" class="btn btn-reset" onclick="resetAll()" style="display: none;">🔄 リセット</button>
            </div>

            <div id="processingInfo" class="processing-info">
                <h3>処理中...</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="processedCount">0</div>
                        <div class="stat-label">処理済み画像</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgReduction">0%</div>
                        <div class="stat-label">平均削減率</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalSavings">0MB</div>
                        <div class="stat-label">容量削減</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="processingTime">0s</div>
                        <div class="stat-label">処理時間</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="resultsSection" class="results-section">
            <div class="main-card">
                <div class="results-header">
                    <h2 class="results-title">処理結果</h2>
                    <div class="download-buttons">
                        <button id="downloadSelectedBtn" class="btn download-selected-btn" onclick="downloadSelected()">
                            📥 選択した画像をダウンロード (<span id="selectedCount">0</span>)
                        </button>
                        <button id="downloadAllBtn" class="btn download-all-btn" onclick="downloadAll()">
                            📥 すべてダウンロード (ZIP)
                        </button>
                    </div>
                </div>
                <div class="select-all-container">
                    <button class="btn select-all-btn" onclick="toggleSelectAll()">
                        <span id="selectAllText">すべて選択</span>
                    </button>
                </div>
                <div id="imageGrid" class="image-grid"></div>
            </div>

            <div class="main-card">
                <h3>元画像（参考）</h3>
                <div id="originalGrid" class="image-grid"></div>
            </div>
        </div>
    </div>

    <!-- プレビューモーダル -->
    <div id="previewModal" class="preview-modal" onclick="closePreviewModal(event)">
        <div class="preview-modal-content">
            <span class="preview-close" onclick="closePreview()">&times;</span>
            <span class="preview-nav preview-prev" onclick="navigatePreview(-1)">‹</span>
            <span class="preview-nav preview-next" onclick="navigatePreview(1)">›</span>
            <div class="preview-container">
                <img id="previewImage" class="preview-image">
                <div class="preview-info">
                    <div id="previewFileName"></div>
                    <div id="previewFileSize"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
        let selectedFiles = [];
        let processedImages = [];
        let startTime;
        let compressionEnabled = true; // デフォルトON
        let selectedImageIndexes = new Set();
        let currentPreviewIndex = 0;

        // 初期化
        document.addEventListener('DOMContentLoaded', function() {
            setupSlider();
            // 圧縮をデフォルトONに設定
            document.getElementById('compressionToggle').classList.add('active');
        });

        // スライダーの設定
        function setupSlider() {
            const slider = document.getElementById('bufferSlider');
            const valueInput = document.getElementById('bufferValue');
            
            // スライダーの背景グラデーション更新
            function updateSliderBackground() {
                const value = slider.value;
                const min = slider.min;
                const max = slider.max;
                const percentage = ((value - min) / (max - min)) * 100;
                slider.style.setProperty('--value', percentage + '%');
            }
            
            // スライダー変更時
            slider.addEventListener('input', function() {
                valueInput.value = this.value;
                updateSliderBackground();
            });
            
            // 数値入力変更時
            valueInput.addEventListener('input', function() {
                let value = parseInt(this.value);
                if (isNaN(value)) value = 70;
                if (value < 0) value = 0;
                if (value > 200) value = 200;
                this.value = value;
                slider.value = value;
                updateSliderBackground();
            });
            
            updateSliderBackground();
        }

        // ファイル選択とドラッグ&ドロップの処理
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.querySelector('.upload-area');

        fileInput.addEventListener('change', handleFileSelect);

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        function handleFileSelect(e) {
            handleFiles(e.target.files);
        }

        function handleFiles(files) {
            selectedFiles = Array.from(files).filter(file => 
                file.type.startsWith('image/')
            );
            
            if (selectedFiles.length > 0) {
                document.querySelector('.upload-text').textContent = 
                    `${selectedFiles.length}枚の画像が選択されました`;
                document.getElementById('processBtn').disabled = false;
            }
        }

        // 圧縮トグル
        function toggleCompression() {
            const toggle = document.getElementById('compressionToggle');
            compressionEnabled = !compressionEnabled;
            toggle.classList.toggle('active', compressionEnabled);
        }

        // リセット機能
        function resetAll() {
            // 変数リセット
            selectedFiles = [];
            processedImages = [];
            selectedImageIndexes.clear();
            
            // UI リセット
            document.querySelector('.upload-text').textContent = '画像をドラッグ&ドロップまたはクリックして選択';
            document.getElementById('processBtn').disabled = false;
            document.getElementById('resetBtn').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('processingInfo').style.display = 'none';
            document.getElementById('fileInput').value = '';
            
            // 進捗リセット
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('processedCount').textContent = '0';
            document.getElementById('avgReduction').textContent = '0%';
            document.getElementById('totalSavings').textContent = '0MB';
            document.getElementById('processingTime').textContent = '0s';
            
            // グリッドクリア
            document.getElementById('imageGrid').innerHTML = '';
            document.getElementById('originalGrid').innerHTML = '';
        }

        // 高精度画像空白検出アルゴリズム
        function detectImageMarginHighPrecision(canvas, ctx, bufferSize) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            const LUMINANCE_THRESHOLD = 30;
            const EDGE_THRESHOLD = 15;
            const MIN_CONTENT_WIDTH = Math.floor(width * 0.1);
            const CONSECUTIVE_ROWS = 3;
            
            let detectedMargin = -1;
            
            for (let y = 0; y < height - CONSECUTIVE_ROWS; y++) {
                let contentPixels = 0;
                let significantChanges = 0;
                
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                    
                    if (luminance > LUMINANCE_THRESHOLD) {
                        contentPixels++;
                    }
                    
                    if (x > 0) {
                        const prevIdx = (y * width + (x - 1)) * 4;
                        const prevLum = 0.299 * data[prevIdx] + 0.587 * data[prevIdx + 1] + 0.114 * data[prevIdx + 2];
                        if (Math.abs(luminance - prevLum) > EDGE_THRESHOLD) {
                            significantChanges++;
                        }
                    }
                }
                
                let consecutiveContentRows = 0;
                for (let checkY = y; checkY < Math.min(y + CONSECUTIVE_ROWS, height); checkY++) {
                    let rowContentPixels = 0;
                    for (let x = 0; x < width; x++) {
                        const idx = (checkY * width + x) * 4;
                        const luminance = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                        if (luminance > LUMINANCE_THRESHOLD) {
                            rowContentPixels++;
                        }
                    }
                    if (rowContentPixels >= MIN_CONTENT_WIDTH) {
                        consecutiveContentRows++;
                    }
                }
                
                if (contentPixels >= MIN_CONTENT_WIDTH && 
                    significantChanges >= 2 && 
                    consecutiveContentRows >= CONSECUTIVE_ROWS) {
                    detectedMargin = y;
                    break;
                }
            }
            
            if (detectedMargin > 0) {
                const verticalProfile = [];
                for (let y = 0; y < height; y++) {
                    let rowIntensity = 0;
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const luminance = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                        rowIntensity += luminance;
                    }
                    verticalProfile.push(rowIntensity / width);
                }
                
                const profileThreshold = Math.max(
                    verticalProfile.slice(0, Math.min(50, height)).reduce((a, b) => Math.max(a, b), 0) * 1.5,
                    LUMINANCE_THRESHOLD
                );
                
                for (let y = 0; y < detectedMargin + 20 && y < height; y++) {
                    if (verticalProfile[y] > profileThreshold) {
                        detectedMargin = Math.min(detectedMargin, y);
                        break;
                    }
                }
            }
            
            if (detectedMargin === -1 || detectedMargin < 5) {
                detectedMargin = Math.floor(height * 0.02);
            }
            
            const finalMargin = Math.max(0, detectedMargin - bufferSize);
            
            return finalMargin;
        }

        // 高品質画像圧縮関数
        async function compressImageHighQuality(canvas, targetSizeKB = 499) {
            return new Promise((resolve) => {
                const targetSizeBytes = targetSizeKB * 1024;
                
                // まず高品質で試す
                canvas.toBlob((blob) => {
                    if (blob.size <= targetSizeBytes) {
                        // すでに目標サイズ以下
                        resolve({ blob, quality: 0.95 });
                    } else {
                        // 品質を段階的に下げて最適値を探す
                        let qualities = [0.92, 0.88, 0.85, 0.82, 0.80, 0.75, 0.70, 0.65, 0.60];
                        let bestBlob = null;
                        let bestQuality = 0;
                        
                        function tryNextQuality(index) {
                            if (index >= qualities.length) {
                                // すべて試した
                                if (bestBlob) {
                                    resolve({ blob: bestBlob, quality: bestQuality });
                                } else {
                                    // 最低品質で圧縮
                                    canvas.toBlob((blob) => {
                                        resolve({ blob, quality: 0.5 });
                                    }, 'image/jpeg', 0.5);
                                }
                                return;
                            }
                            
                            const q = qualities[index];
                            canvas.toBlob((blob) => {
                                if (blob.size <= targetSizeBytes) {
                                    // 目標達成、これが最高品質
                                    resolve({ blob, quality: q });
                                } else {
                                    // まだ大きい、次を試す
                                    tryNextQuality(index + 1);
                                }
                            }, 'image/jpeg', q);
                        }
                        
                        tryNextQuality(0);
                    }
                }, 'image/jpeg', 0.95);
            });
        }

        // 画像処理メイン関数
        async function processImages() {
            if (selectedFiles.length === 0) {
                alert('画像を選択してください。');
                return;
            }

            startTime = Date.now();
            document.getElementById('processingInfo').style.display = 'block';
            document.getElementById('processBtn').disabled = true;
            
            processedImages = [];
            selectedImageIndexes.clear();
            let totalOriginalSize = 0;
            let totalProcessedSize = 0;

            const bufferSize = parseInt(document.getElementById('bufferValue').value) || 70;

            for (let i = 0; i < selectedFiles.length; i++) {
                const file = selectedFiles[i];
                
                try {
                    const result = await processImage(file, bufferSize);
                    processedImages.push(result);
                    
                    totalOriginalSize += result.originalSize;
                    totalProcessedSize += result.processedSize;
                    
                    // 進捗更新
                    const progress = ((i + 1) / selectedFiles.length) * 100;
                    document.getElementById('progressBar').style.width = progress + '%';
                    document.getElementById('processedCount').textContent = i + 1;
                    
                    if (totalOriginalSize > 0) {
                        const avgReduction = Math.round(((totalOriginalSize - totalProcessedSize) / totalOriginalSize) * 100);
                        document.getElementById('avgReduction').textContent = avgReduction + '%';
                        document.getElementById('totalSavings').textContent = 
                            ((totalOriginalSize - totalProcessedSize) / (1024 * 1024)).toFixed(1) + 'MB';
                    }
                    
                    const elapsedTime = Math.round((Date.now() - startTime) / 1000);
                    document.getElementById('processingTime').textContent = elapsedTime + 's';
                    
                } catch (error) {
                    console.error('画像処理エラー:', error);
                }
            }

            // 結果表示
            displayResults();
            document.getElementById('processingInfo').style.display = 'none';
            document.getElementById('processBtn').disabled = false;
            document.getElementById('resetBtn').style.display = 'inline-block';
        }

        async function processImage(file, bufferSize) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = async function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    // 高精度検出アルゴリズムを使用
                    const marginY = detectImageMarginHighPrecision(canvas, ctx, bufferSize);
                    
                    // 切り取り処理
                    const croppedHeight = img.height - marginY;
                    const croppedCanvas = document.createElement('canvas');
                    const croppedCtx = croppedCanvas.getContext('2d');
                    
                    croppedCanvas.width = img.width;
                    croppedCanvas.height = croppedHeight;
                    
                    croppedCtx.drawImage(img, 0, marginY, img.width, croppedHeight, 0, 0, img.width, croppedHeight);
                    
                    // 圧縮処理
                    let finalBlob;
                    let wasCompressed = false;
                    
                    if (compressionEnabled) {
                        const compressionResult = await compressImageHighQuality(croppedCanvas, 499);
                        finalBlob = compressionResult.blob;
                        wasCompressed = true;
                    } else {
                        finalBlob = await new Promise(resolve => {
                            croppedCanvas.toBlob(resolve, 'image/jpeg', 0.95);
                        });
                    }
                    
                    const originalSize = file.size;
                    const processedSize = finalBlob.size;
                    const reductionPercent = Math.round(((originalSize - processedSize) / originalSize) * 100);
                    
                    resolve({
                        originalFile: file,
                        originalUrl: URL.createObjectURL(file),
                        processedBlob: finalBlob,
                        processedUrl: URL.createObjectURL(finalBlob),
                        originalSize: originalSize,
                        processedSize: processedSize,
                        reductionPercent: reductionPercent,
                        marginRemoved: marginY,
                        wasCompressed: wasCompressed
                    });
                };
                
                img.src = URL.createObjectURL(file);
            });
        }

        function displayResults() {
            const resultsSection = document.getElementById('resultsSection');
            const imageGrid = document.getElementById('imageGrid');
            const originalGrid = document.getElementById('originalGrid');
            
            imageGrid.innerHTML = '';
            originalGrid.innerHTML = '';
            
            processedImages.forEach((result, index) => {
                // 処理後画像
                const processedItem = document.createElement('div');
                processedItem.className = 'image-item';
                processedItem.setAttribute('data-index', index);
                
                const compressionBadge = result.wasCompressed ? 
                    '<div class="compressed-badge">圧縮済み</div>' : '';
                
                processedItem.innerHTML = `
                    <div class="image-checkbox" onclick="toggleImageSelection(${index}, event)"></div>
                    <div class="image-container" onclick="showPreview(${index})">
                        <img src="${result.processedUrl}" class="result-image" alt="処理済み画像">
                    </div>
                    <div class="image-info">
                        <div class="original-name">${result.originalFile.name}</div>
                        <div class="size-reduction">${result.reductionPercent}% 削減</div>
                        <div>${Math.round(result.processedSize / 1024)}KB</div>
                        ${compressionBadge}
                    </div>
                `;
                imageGrid.appendChild(processedItem);
                
                // 元画像
                const originalItem = document.createElement('div');
                originalItem.className = 'image-item';
                originalItem.innerHTML = `
                    <div class="image-container" onclick="showOriginalPreview('${result.originalUrl}', '${result.originalFile.name}', ${result.originalSize})">
                        <img src="${result.originalUrl}" class="result-image" alt="元画像">
                    </div>
                    <div class="image-info">
                        <div class="original-name">${result.originalFile.name}</div>
                        <div>${Math.round(result.originalSize / 1024)}KB</div>
                    </div>
                `;
                originalGrid.appendChild(originalItem);
            });
            
            resultsSection.style.display = 'block';
            updateSelectedCount();
        }

        // 画像選択機能
        function toggleImageSelection(index, event) {
            event.stopPropagation();
            const imageItem = document.querySelector(`[data-index="${index}"]`);
            const checkbox = imageItem.querySelector('.image-checkbox');
            
            if (selectedImageIndexes.has(index)) {
                selectedImageIndexes.delete(index);
                imageItem.classList.remove('selected');
                checkbox.classList.remove('checked');
            } else {
                selectedImageIndexes.add(index);
                imageItem.classList.add('selected');
                checkbox.classList.add('checked');
            }
            
            updateSelectedCount();
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = selectedImageIndexes.size;
            document.getElementById('downloadSelectedBtn').disabled = selectedImageIndexes.size === 0;
        }

        function toggleSelectAll() {
            const allIndexes = processedImages.map((_, index) => index);
            const selectAllText = document.getElementById('selectAllText');
            
            if (selectedImageIndexes.size === processedImages.length) {
                // すべて選択解除
                selectedImageIndexes.clear();
                document.querySelectorAll('.image-item').forEach(item => {
                    item.classList.remove('selected');
                    const checkbox = item.querySelector('.image-checkbox');
                    if (checkbox) checkbox.classList.remove('checked');
                });
                selectAllText.textContent = 'すべて選択';
            } else {
                // すべて選択
                allIndexes.forEach(index => selectedImageIndexes.add(index));
                document.querySelectorAll('[data-index]').forEach(item => {
                    item.classList.add('selected');
                    const checkbox = item.querySelector('.image-checkbox');
                    if (checkbox) checkbox.classList.add('checked');
                });
                selectAllText.textContent = '選択解除';
            }
            
            updateSelectedCount();
        }

        // プレビュー機能
        function showPreview(index) {
            currentPreviewIndex = index;
            const result = processedImages[index];
            
            document.getElementById('previewImage').src = result.processedUrl;
            document.getElementById('previewFileName').textContent = result.originalFile.name;
            document.getElementById('previewFileSize').textContent = 
                `${Math.round(result.processedSize / 1024)}KB (${result.reductionPercent}% 削減)`;
            
            document.getElementById('previewModal').style.display = 'block';
        }

        function showOriginalPreview(url, filename, size) {
            document.getElementById('previewImage').src = url;
            document.getElementById('previewFileName').textContent = filename;
            document.getElementById('previewFileSize').textContent = `${Math.round(size / 1024)}KB`;
            document.getElementById('previewModal').style.display = 'block';
        }

        function closePreview() {
            document.getElementById('previewModal').style.display = 'none';
        }

        function closePreviewModal(event) {
            if (event.target.classList.contains('preview-modal')) {
                closePreview();
            }
        }

        function navigatePreview(direction) {
            currentPreviewIndex = (currentPreviewIndex + direction + processedImages.length) % processedImages.length;
            showPreview(currentPreviewIndex);
        }

        // ダウンロード機能
        async function downloadSelected() {
            if (selectedImageIndexes.size === 0) {
                alert('ダウンロードする画像を選択してください。');
                return;
            }
            
            if (selectedImageIndexes.size === 1) {
                // 1枚の場合は直接ダウンロード
                const index = Array.from(selectedImageIndexes)[0];
                const result = processedImages[index];
                const url = result.processedUrl;
                const a = document.createElement('a');
                a.href = url;
                a.download = result.originalFile.name.replace(/\.[^/.]+$/, '') + '_processed.jpg';
                a.click();
            } else {
                // 複数枚の場合はZIP
                const zip = new JSZip();
                
                for (const index of selectedImageIndexes) {
                    const result = processedImages[index];
                    const fileName = result.originalFile.name.replace(/\.[^/.]+$/, '') + '_processed.jpg';
                    zip.file(fileName, result.processedBlob);
                }
                
                const zipBlob = await zip.generateAsync({type: 'blob'});
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'selected_images.zip';
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        async function downloadAll() {
            const zip = new JSZip();
            
            for (const result of processedImages) {
                const fileName = result.originalFile.name.replace(/\.[^/.]+$/, '') + '_processed.jpg';
                zip.file(fileName, result.processedBlob);
            }
            
            const zipBlob = await zip.generateAsync({type: 'blob'});
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'processed_images.zip';
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
